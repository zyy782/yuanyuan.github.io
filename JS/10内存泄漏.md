### 什么是内存泄漏  
 **不再用到的内存，没有及时释放，就叫做内存泄漏。**    
 JS有自己的内存回收机制，可以确定哪些变量不再需要，并将其清除，但这并不代表着开发者可以不关心内存管理。你还是需要关注内存占用：那些不在需要但依旧占用内存的值，必须手动解除引用     
 比如说：   
 ```
let arr = [1, 2, 3, 4, 5];
console.log('hello world');
arr = null;
 ```
 变量arr引用了数组[1,2,3,4,5],后面的代码不再需要它，就需要手动释放这个内存。即将arr重置为null，使其引用次数为0。


在了解垃圾回收算法之前，我们要先明白JS的内存管理机制
### js内存管理机制   
JavaScript 内存管理机制和内存的生命周期是一一对应的。   
也就是**分配内存、使用内存、释放内存**。   
#### 内存分配   
JS在定义变量时会自动分配内存   
#### 内存使用   
内存的使用实际上是对分配的内存进行读写的过程。比如说赋值（写入一个变量或者对象的属性值）、传参（传递函数的参数）   
```
// 写入内存
number = 234;
// 读取 number 和 func 的内存，写入 func 参数内存
func(number);
```  
#### 内存回收 （Garbage Collection）
 JS有自己的内存回收机制，可以确定哪些变量不再需要，并将其清除。它可以清除绝大多数的垃圾内存，清除不了时需要我们手动回收。


 ### 垃圾回收算法   
 #### 1.引用计数
 js引用引擎中有一个“引用表”，记录着内存中所有资源的引用次数。如果这个引用次数是0（零引用），就代表这个值已经不会再用了，可以释放这块内存了。    
 当一个值不再被需要了，但是他的引用值却不是0，垃圾回收机制无法释放这块内存，这个时候就会导致内存泄漏。    
 MDN的一个例子
 ```
     var o = {
        a: {
            b: 2
        }
    };
    // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
    // 很显然，没有一个可以被垃圾收集

    var o2 = o; // o2变量是第二个对“这个对象”的引用

    o = 1; // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

    var oa = o2.a; // 引用“这个对象”的a属性
    // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

    o2 = "yo"; // 虽然最初的对象现在已经是零引用了，但是它的属性a的对象还在被oa引用，所以还不能回收

    oa = null; // a属性的那个对象现在也是零引用了
    // js回收机制看到是零引用时候，就会自动回收这个垃圾内存
 ```
 引用计数的**缺点**：  
 **无法处理循环引用的事例**  
在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 
 ```
 function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
 ```

##### 强引用和弱引用
ES6 把引用有区分为强引用和弱引用，这个目前只有再 Set 和 Map 中才有。

强引用才会有引用计数叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（手动回收的前提在于标记清除法还没执行，还处于当前执行环境）。

而弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。

 #### 2.标记清除   
 核心：**可达内存被标记，其余的被当作垃圾回收**     
 标记清除算法：    
 假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，查找所有从根开始引用的对象，然后找这些对象引用的对象找到的会给它一个标记。最后没有标记的就会被当做垃圾释放。     
  
看到一个这样的解释，也很好理解：   

### 内存泄漏的一些场景   
1. 全局变量   
   在**非严格模式下**当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window  
   ```
   function foo（arg）{ 
    bar =“some text”; // bar将泄漏到全局.
   }
   ```
   全局变量根据定义无法被垃圾回收机制收集!!(请确保将其指定为null或在完成后重新分配它)
2. 被遗忘的定时器    
   比如说，在组件中moutend里开启定时器，组件销毁的时候，定时器依旧在运行，里面的内存会被浏览器认为这只必须的内存而无法回收它们。   
   这个时候，我们就需要在组件销毁时，及时清除定时器。
3. 被遗忘的回调函数    
   比如在mounted里添加了``` window.addEventListener('A事件',()=>{})```监听事件，在组件销毁的时候，A事件依旧在监听中，里面的内存会被浏览器认为这只必须的内存而无法回收它们。   
   这个时候我们就需要在组件销毁时移除相关事件。```window.removeEventListener   ```    
4. [闭包](https://segmentfault.com/a/1190000039132414)  
   