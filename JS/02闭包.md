### 闭包
一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，<b>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</b>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。   
简单理解，<b>闭包是指有权访问另外一个函数作用域中的变量的函数</b>   

##### 未使用闭包
执行完for循环后，data是[Function (anonymous),Function (anonymous),Function (anonymous)]的形式,因为以下代码只是将函数赋值给data[i],并没有执行。
```
data[i] = function() {
        console.log(i);
    };
```
i = 3 时,for循环结束，执行下面的```data[0]()、data[1]()、data[2]()```三个函数，输出的都是3   
for循环在主线程中，只有for循环执行完，等待队列中的```data[0]()、data[1]()、data[2]()```三个函数才进入主线程被执行

```
var data = [];

for (var i = 0; i < 3; i++) {
    data[i] = function() {
        console.log(i);
    };
}

data[0](); //3
data[1](); //3
data[2](); //3
```

##### 使用闭包
这里用匿名函数实现了闭包   
也就是内部return的这个函数和当时这个函数所定义的环境中   
这里把立即执行函数赋值给data[i],并把当前循环的i作为实参传入这个立即执行的匿名函数。    
所以在for循环赋值时，它已经把当前的i传入了这个return函数中，for循环结束时，输出0 1 2


自执行的匿名函数的作用：**每一次循环创建一个私有词法环境，执行时把当前的循环的i传入，保存在这个词法环境中**  


```
var data = [];

for (var i = 0; i < 3; i++) {
    data[i] = (function(i) {
        return function() {
            console.log(i);
        }
    })(i);
}

data[0]();//0
data[1]();//1
data[2]();//2
```