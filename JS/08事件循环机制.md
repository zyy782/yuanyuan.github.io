我们都知道，JS是单线程的，而浏览器内核是多线程的，为了使我们的异步代码在浏览器可以很好地运行，js有一套机制———“事件循环机制”。    
总体来说，就是“先同步再异步，异步中[先微任务再宏任务](https://github.com/zyy782/yuanyuan.github.io/blob/main/Promise/08js%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97.md)”     
简单理解：   
1. js执行任务时会首先区分是同步任务还是异步任务   
   如果是同步任务，则进入主线程，异步任务则进入时间表并注册回调函数，注册的回调函数在任务队列中等待。
2. 主线程中的同步任务执行完毕时，就会去任务队列中读取对应的函数，把它推入主线程执行栈进行调用。
3. 在任务队列中读取对应函数时，js会先读取微任务，再读取宏任务。
4. 该过程会不断循环重复，也就是所说的“事件循环（Event Loop）”


搬运一个博主的整理，觉得写得很详细了    
https://segmentfault.com/a/1190000038928521 

【案例1】
```
console.log('1'); //立即执行

setTimeout(function() { //进入宏任务队列
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() { //进入微任务队列
    console.log('6');
})
new Promise(function(resolve) { //立即执行
    console.log('7');
    resolve();
}).then(function() { //then进入微任务队列
    console.log('8')
})

setTimeout(function() { //进入宏任务队列
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

// 1 7 6 8 2 4 3 5 9 11 10 12
/**
 * 第一轮循环，输出： 1  7  6  8
 * 第二轮循环，输出： 2  4  3  5
 * 第三轮循环，输出： 9  11 10 12
 *     
 */
```

【案例2】
```
function testSometing() {
    console.log("执行testSometing");
    return "testSometing";
}

async function testAsync() {
    console.log("执行testAsync");
    return Promise.resolve("hello async");
}

async function test() {
    console.log("test start...");
    const v1 = await testSometing(); //关键点1
    console.log(v1);
    const v2 = await testAsync();
    console.log(v2);
    console.log(v1, v2);
}

test();

var promise = new Promise((resolve) => {
    console.log("promise start..");
    resolve("promise");
}); //关键点2
promise.then((val) => console.log(val));

console.log("test end...")
```
案例2分析：    
调用test()时，首先执行```console.log("test start...");```    
然后执行``` const v1 = await testSometing(); //关键点1```    
此时，执行完testSometing()，await会让出线程，因此会转去去执行 关键点2处的代码，也就是```console.log("promise start..");```
然后执行```console.log("test end...")```    

到此，第一轮循环结束   
然后，跳到async函数中，继续执行await 后面表达式的返回值```console.log(v1);```    第二轮循环开始，执行到```const v2 = await testAsync();```时，同理。    

最终的执行顺序如下：    
```
test start...
执行testSometing
promise start..
test end...
testSometing
执行testAsync
promise
hello async
testSometing hello async
```


【案例3】
```
setTimeout(function() {
    console.log("1");
}, 0);
async function async1() {
    console.log("2");
    const data = await async2();
    console.log("3");
    return data;
}
async function async2() {
    return new Promise((resolve) => {
        console.log("4");
        resolve("async2的结果");
    }).then((data) => {
        console.log("5");
        return data;
    });
}
// async1()
async1().then((data) => {
    console.log("6");
    console.log(data);
});
new Promise(function(resolve) {
    console.log("7");
    resolve()
}).then(function() {
    console.log("8");
});
```
执行顺序：   
2  4 7 5 8 3 6 async2的结果 1






 
