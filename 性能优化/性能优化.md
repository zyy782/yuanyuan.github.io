## 性能优化
前端性能优化可以从以下几个方面入手：

## 1. **减少HTTP请求**
   - **合并文件**：将多个CSS或JS文件合并为一个，减少请求次数。
   - **使用CSS Sprites**：将多个小图标合并为一张大图，通过背景定位显示。
   - **内联资源**：将小图片或CSS/JS代码直接嵌入HTML中，减少请求。

## 2. **优化资源加载**
   - **[延迟加载（懒加载）](../性能优化/优化资源加载.md)**：对非关键资源（如图片、JS）使用延迟加载，优先加载核心内容。
   - **异步加载**：使用`async`或`defer`属性异步加载JS文件，避免阻塞渲染。
   - **预加载**：通过`<link rel="preload">`提前加载关键资源。

## 3. **压缩资源**
   - **压缩文件**：使用工具（如Gzip、Brotli）压缩HTML、CSS、JS文件。
   - **压缩图片**：使用工具（如ImageOptim、TinyPNG）压缩图片，或使用WebP格式。
   - **精简代码**：移除无用代码、注释和空格，使用工具（如UglifyJS、CSSNano）进行压缩。

## 4. **使用缓存**
   - **浏览器缓存**：通过设置HTTP头（如`Cache-Control`、`Expires`）缓存静态资源。
   - **Service Worker**：使用Service Worker实现离线缓存和资源预加载。
   - **CDN加速**：使用CDN分发静态资源，减少延迟。

## 5. **优化CSS和JS**
   - **减少重排和重绘**：避免频繁操作DOM，使用`transform`和`opacity`等属性减少重绘。
   - **使用CSS动画**：优先使用CSS动画而非JS动画，提升性能。
   - **避免阻塞渲染**：将CSS放在`<head>`中，JS放在`<body>`末尾或使用`defer`/`async`。

## 6. **优化DOM操作**
   - **减少DOM访问**：缓存DOM查询结果，避免重复查找。
   - **批量更新DOM**：使用文档片段（`DocumentFragment`）或虚拟DOM批量更新。
   - **事件委托**：使用事件委托减少事件监听器数量。

## 7. **优化图片和媒体**
   - **响应式图片**：使用`srcset`和`<picture>`标签根据设备加载合适尺寸的图片。
   - **懒加载图片**：延迟加载非首屏图片，提升首屏加载速度。
   - **视频优化**：使用合适的格式（如MP4、WebM），并延迟加载非首屏视频。

## 8. **减少重定向**
   - **避免不必要的重定向**：减少HTTP重定向次数，降低延迟。
   - **使用正确的URL**：确保URL正确，避免自动重定向。

## 9. **使用Web Workers**
   - **后台任务**：将耗时任务（如数据处理）放到Web Workers中执行，避免阻塞主线程。
## 10. **监控和分析**
   - **性能监控**：使用工具（如Lighthouse、WebPageTest）分析性能瓶颈。
   - **持续优化**：定期监控性能，持续优化关键指标（如FCP、TTI）。

## 11. **优化字体**
   - **字体子集化**：仅加载需要的字符集，减少字体文件大小。
   - **使用`font-display`**：通过`font-display: swap`避免字体加载时的空白文本。

## 12. **减少第三方脚本**
   - **按需加载**：仅在需要时加载第三方脚本。
   - **异步加载**：使用`async`或`defer`加载第三方脚本，避免阻塞。

## 13. **优化首屏加载**
   - **关键CSS**：将首屏所需CSS内联到HTML中，减少渲染阻塞。
   - **骨架屏**：使用骨架屏提升用户体验，减少白屏时间。

## 14. **使用HTTP/2**
   - **多路复用**：利用HTTP/2的多路复用特性，减少请求延迟。
   - **服务器推送**：通过HTTP/2服务器推送提前发送关键资源。

## 15. **优化Webpack构建**
   - **代码分割**：使用`SplitChunksPlugin`进行代码分割，按需加载。
   - **Tree Shaking**：移除未使用的代码，减少打包体积。
   - **压缩代码**：使用`TerserPlugin`压缩JS，`CssMinimizerPlugin`压缩CSS。

通过这些优化措施，可以显著提升前端性能，改善用户体验。



### 打包优化

优化一：打包后的结果，上线时的性能优化。（比如分包处理、减小包体积、CDN服务器等）
优化二：优化打包速度，开发或者构建时优化打包速度。（比如exclude、cache-loader等）
大多数情况下，我们会更加侧重于优化一，这对于线上的产品影响更大。
在大多数情况下webpack都帮我们做好了该有的性能优化：
比如配置mode为production或者development时，默认webpack的配置信息, 但是我们也可以针对性的进行自己的项目优化，我们来看下未优化前的oms-web包分析，我们将hui.config.js文件下analyze打开。借助webpack-bundle-analyzer 来分析下包内容，它是 webpack 的一个插件，将打包文件可视化展现，生成代码分析报告，可以直观地分析打包出的文件有哪些，及它们的大小、占比情况、各文件 Gzipped 后的大小、模块包含关系、依赖项等，对应做出优化，从而帮助提升代码质量和网站性能

优化前：
<img src="../pictures/youhua01.png">
我们可以看未优化前的整包大小为15.72MB，同时首次加载的hswealth-oms.js 为 3.36MB, 下面是网络加载时序图
<img src="../pictures/youhua02.png">


从上图中，我们可以看到hswealth-oms的整体文件较大，我们进行拆分，里面包含了一些非首次加载必须的依赖，比如@hui/treegrid、1.0低码资源等



分析：
将大的包进行拆分，一些页面用到的大组件放到页面中，不放在index中加载（提升首屏性能）



#### Webpack的代码分割配置：

```
configWp.optimization.splitChunks = {
  chunks: 'all', // 指定对哪些类型的chunks应用代码分割，可选值有 'async' (默认)、'initial' 或 'all'
  cacheGroups: {
    vendors: { // 第三方库分离
      test: /[\\/]node_modules[\\/]/,
      priority: -10, // 优先级，数值越大优先级越高
      filename: 'vendors.js', // 输出文件名
      reuseExistingChunk: true, // 如果一个模块已经在主 chunk 里，就直接使用，不会重新生成
    },
    defaultVendors: { // 默认的第三方库分离
      priority: -20,
      test: /[\\/]node_modules[\\/]/,
      reuseExistingChunk: true,
    },
    default: { // 默认分离
      minChunks: 2, // 至少被两个chunks共享才会被打包到同一chunk
      priority: -20,
      reuseExistingChunk: true,
    }
  }
};
```
>```vendors```：这个缓存组主要用于将项目中用到的所有第三方库（位于 node_modules 中的模块）打包到单独的 vendors.js 文件中。
```defaultVendors```：与 ```vendors``` 类似，但是优先级较低，可以用来处理一些特殊情况。
```default```：当模块不匹配任何其他缓存组时，默认的缓存组会起作用，这里设置了至少被两个 chunks 共享的模块才会被打包到同一个 chunk 中。
通过这种方式，你可以更好地控制Webpack如何分割代码，并且有助于提升应用的加载性能。

#### webpack使用 TerserPlugin 进行JavaScript代码压缩
```
configWp.optimization.minimizer = [
  new TerserPlugin({
    terserOptions: {
      compress: {
        arrows: false,
        collapse_vars: false,
        comparisons: false,
        computed_props: false,
        hoist_funs: false,
        hoist_props: false,
        hoist_vars: false,
        inline: false,
        loops: false,
        negate_iife: false,
        properties: false,
        reduce_funcs: false,
        reduce_vars: false,
        switches: false,
        toplevel: false,
        typeofs: false,
        booleans: true,
        if_return: true,
        sequences: true,
        unused: true,
        conditionals: true,
        dead_code: true,
        evaluate: true,
        drop_console: true, //  移除所有 console 调用。
        drop_debugger: true, // 移除所有 debugger 语句。
        pure_funcs: ['console.log'] // 将 console.log 视为纯函数，即在某些情况下可以安全地移除。
      },
      mangle: {
        safari10: true // 使变量名称在Safari 10中兼容
      }
    },
    sourceMap: false, // 不生成源映射文件
    cache: true, // 启用缓存以加速构建过程
    parallel: 3, // 表示并发运行3个线程进行压缩
    extractComments: false, // 不提取注释
    exclude: [ // 以下文件不进行压缩
      'sysconfig.js',
      /static/
    ]
  })
];
```
>源映射文件（Source Map）是一种机制，它允许你在压缩后的代码中调试**原始的未压缩代码**。这对于开发和调试阶段非常有用，因为压缩后的代码通常难以阅读和调试。