### 一键回到顶部功能的实现
1. 引入组件并绑定点击事件，v-show决定组件是否显示<br>
   ```<back-top @click.native="backClick" v-show="isShowBackTop"></back-top>```
2. 监听滚动事件<br>
```
  mounted() {
    window.addEventListener("scroll", this.debounce(this.handleScroll,300), true)
  },
```
3. 实现handleScroll方法，保存滚动值，判断图标是否出现<br>
```
handleScroll() {
      this.scrollTop = document.documentElement.scrollTop
      if (this.scrollTop > 200) {
        this.isShowBackTop = true
      }
    },
```
4. 实现回到顶部方法<br>
```
backClick() {
    document.documentElement.scrollTop = 0
    this.isShowBackTop = false
},
```

5. #### 节流（throttle）与防抖（debounce）
   ##### 防抖
   在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br>
   频繁操作时不会发送请求，只有在指定间隔内不操作时才会执行函数<br>

   1. 普通方法<br>
     
   ```
   var timer; // 维护同一个timer
      function debounce(fn, delay) {
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn();
        }, delay);
      }
   ```
   2. 闭包<br>
      闭包使我们可以在内层函数中可以访问到其外层函数的作用域
   ```
    //借助闭包
     debounce(fn,delay){
      let timer = null;
      return function () {
        if(timer){
          clearTimeout(timer)
        }
        timer = setTimeout(fn,delay);        
      }
    }
   ```
   ##### 节流
   规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
   ```
     function throttle(fn, delay) {
        let timer;
        return function () {
            if (timer) {
                //如果timer不为空，说明还在时间间隔内，不触发事件
                return;
            }
            let context = this;
            let args = arguments;
            timer = setTimeout(() => {
                fn.apply(context, args);
                timer = null; //执行一次后要将timer置为null，这里就是节流与防抖的区别
            }, delay);
        };
    }
   ```