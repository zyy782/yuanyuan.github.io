### [前端性能优化](https://www.cnblogs.com/lanxiansen/p/10972802.html?ivk_sa=1025922x)
1. 图片的懒加载----->减少首次加载的http请求次数
2. 尽量合并、压缩CSS、js文件（打包：webpack、gulp）----->减少http请求次数和请求资源的大小
3. 使用SVG、字体图标代替png；使用精灵图
4. 减少cookie的使用----->减少客户端的存储量
5. 前后端数据交互尽量使用json合适----->资源小，数据处理方便
6. 减少dom操作
7. 导入css少用@import，尽量用link----->@import同步，link异步
8. 避免使用iframe----->iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大
### [前端常见的安全性问题及解决方法]()
1. **XSS跨站脚本攻击**   
   攻击者通过注入非法的html标签或者javascript代码，从而当用户浏览该网页时，控制用户浏览器。   
   解决方法：   
   + **过滤用户的输入**    
     通过将<> '' ""等字符进行转义，移除用户输入的Style节点、Script节点、Iframe节点。 
   + **设置httponly属性**    
     在cookie中设置HttpOnly属性，使js脚本无法读取到cookie信息。
  > 预防DOM型XSS攻击的方法：
  1.在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.   setAttribute() 等。
  2.DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，\<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。
  3.如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免innerHTML、outerHTML 的 XSS 隐患
  预防 XSS 攻击其他方法：
  1.开启CSP网页安全政策防止XSS攻击，Content-Security-Policy 中文的意思是网页安全政策，我们只需要在meta属性中设置下即可使用：如下代码： ```<meta http-equiv="Content-Security-Policy" content="">```
  2.当下React、Vue等框架都从框架层面引入了 XSS 防御机制，一定程度上解放了我们的双手。 但是作为开发人员依然要了解 XSS 基本知识、于细节处避免制造 XSS 漏洞。
  3.X-XSS-Protection设置，目前该属性被所有的主流浏览器默认开启XSS保护。该参数是设置在响应头中目的是用来防范XSS攻击的。
2. **CSRF跨站请求伪造**     
   攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 
   解决方法：  
   + **token**
     由于每次发送需要用户权限的请求都需要携带token或者将token放置在请求头的某处，浏览器不会自动携带。通常token会以本地存储的方式寄存到浏览器中，而恶意网页不具备跨域访问token的能力，自然也不能成功的执行操作，这也是现在市面上大部分API接口的使用方法
   + **Referer验证**
     eferer 指的是页面请求来源，意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。具体方案：为请求头加上一个referer字段，其指向跳转页面之前或者发送请求的那个页面url，这样服务端就知道请求源在哪里，对其进行验证即可知道是在哪个页面发送的请求，要不要为其执行操作和响应数据。
   + **使用验证码**
     由于浏览器发送请求的时候会携带cookie，但因为攻击者在恶意网站中由于同源政策的限制，其并不可以跨域访问到另一个域下面的cookie，所以我们可以跟服务端进行协商，通过在cookie中取某一个字段作为验证的筹码，这样就可以判断请求是不是恶意发送的了，这种方法也被称为cookie双重验证。
3. **本地存储数据泄漏**    
   解决方案：     
   + **不在本地存储重要数据**
   + **加密**   
     所有在放到cookie中的信息或者localStorage里的信息要进行加密

## cookie session 与 token
### cookie
cookie 最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，请求就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种背景下，就产生了 cookie。
**cookie 存储在客户端， cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上**。
因此，服务端脚本就可以读、写存储在客户端的cookie的值。
cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名（绑定域名下的子域都是有效的），无法在别的域名下获取使用，同域名不同端口也是允许共享使用的。

<img src="https://img-blog.csdnimg.cn/2020021118314641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70" />

### session
session 是基于 cookie 实现的，==session 存储在服务器端，sessionId 会被存储到客户端的cookie 中==。
>在Web开发中，session 和 sessionID 是两个密切相关的概念，通常用于管理用户的会话状态。
Session（会话）：
session是服务器端用于存储用户会话数据的机制。它允许在用户与Web应用程序的交互过程中保存用户的状态和信息。
例如，当用户登录到一个网站时，服务器可以在session中存储用户的登录状态、用户ID等信息，以便在后续请求中识别用户。
SessionID（会话ID）：
sessionID是一个唯一的标识符，用于标识特定用户的会话。它通常是一个随机生成的字符串。
当用户首次访问网站时，**服务器会生成一个sessionID并将其发送给客户端（通常通过cookie）**。在后续请求中，客户端会将这个sessionID发送回服务器，以便服务器识别和检索与该会话相关的数据。
总结来说，session是存储用户会话数据的容器，而sessionID是用于识别和访问该容器的钥匙。

实际上session 和sookie是类似的一种维持客户端和服务会话状态的技术，不过
**session 安全性要比cookie高**，这是因为 session 的数据是存放在服务端上的，所以 session 被应用于储存一些比较隐私的数据，例如用户名密码和用户的资料等  
服务器中的session数据是被封装在一个对象里，而这个对象会被保存在对象池中，客户端发送请求时，服务器会首先检查该请求是否包含sessionID，如果包含，服务端就会根据这个sessionID，来从对象池中获得相应的session对象，从对象中获得session的具体数据;如果没有，就会创建一个sessionId和对应的session，这个session id将被在本次响应中返回给客户端保存。具体流程如下：  

<img src="https://img-blog.csdnimg.cn/20200212121540431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70"/>

> cookie 与 session 的区别
> 1. 存储位置：
> + Cookie是存储在客户端（浏览器）上的。这意味着用户可以直接访问和修改cookie数据。
> + Session是存储在服务器端的。客户端只保存一个session ID，这个ID用于在服务器上查找对应的session数据。
> 2. 数据安全性：
> + 由于cookie存储在客户端，容易被用户或恶意软件篡改，安全性较低。
> + Session数据存储在服务器上，用户无法直接访问和修改，安全性更高。
> 3. 数据大小限制：
> + Cookie通常有大小限制（一般为4KB），这限制了可以存储的数据量,很多浏览器都限制一个站点最多保存20个cookie。
> + Session存储在服务器上，理论上可以存储更多的数据，具体限制取决于服务器配置。
> 4. 生命周期：
> + Cookie可以设置过期时间，可能会在用户关闭浏览器后仍然存在。
> + Session通常在用户关闭浏览器或会话超时后失效，提供了更短暂的生命周期，减少了被攻击的风险。
> 5. 传输安全性：
> + Cookie在传输过程中可能被拦截，尤其是在未使用HTTPS的情况下。
> + Session ID可以通过HTTPS加密传输，降低被拦截的风险。


### token
token的全称为 Json Web Token（简称JWT），是基于Json的一个公开规范，这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。简单说就是**由服务端根据规范生成一个令牌（token），并且发放给客户端。此时客户端请求服务端的时候就可以携带着令牌，以令牌来证明自己的身份信息**。通过token来代表用户身份。与使用session保持登录状态不同的是，JWT不需要保存认证记录，只需保存密钥。


##### token认证的优势
1. **无状态性**：
Token认证是无状态的，服务器不需要存储用户的会话信息。这使得应用更容易扩展，因为不需要在服务器之间共享会话状态。
2. **跨域支持**：
Token可以在不同的域之间传递，这使得在跨域请求中使用Token认证变得非常方便。
3. **移动友好**：
移动端不支持cookie，但是token认证不依赖于cookie,可以直接在HTTP请求头中传递,因此它非常适合移动应用。
4. **安全性**：
Token通常是加密的，包含了用户的身份信息和过期时间，难以伪造。
使用HTTPS可以确保Token在传输过程中不被拦截。
5. **灵活性**：
Token可以携带更多的信息，比如用户角色和权限，这使得在不同的请求中可以进行更细粒度的权限控制。
6. **易于集成**：
Token认证可以很容易地与OAuth等标准协议集成，支持第三方登录和授权。
7. **短生命周期**：
Token通常有较短的生命周期，过期后需要重新获取，这减少了被盗用的风险。
8. **注销简单**：
由于Token是无状态的，注销只需在客户端删除Token即可，不需要在服务器上进行额外的操作。


>总的来说token的优点是轻便,在跨域资源共享时非常方便。例如在第三方授权时，只需要将token给对方，可以对用户的信息进行保密。在用户非常多时，也非常地快捷，解密后对比token而不是在session中获取用户信息来对比。由于token具有时效性，后端也可以进行设置时效果，所有也非常安全


##### 为什么Token认证可以有效防止CSRF（跨站请求伪造）攻击呢?
> 1. **不依赖Cookie**：
> **CSRF攻击通常利用用户浏览器中自动发送的cookie来伪造请求**。Token认证不依赖于cookie，而是通过HTTP头（如Authorization头）传递Token，这使得攻击者无法利用用户的cookie来进行伪造请求。
> 2. **需要显式传递Token**：
> 在Token认证中，客户端需要显式地在请求中包含Token。攻击者无法在受害者不知情的情况下获取或使用这个Token，因为Token通常存储在客户端的安全存储中（如浏览器的localStorage或sessionStorage），而不是自动附加在请求中。
> 3. **Token的唯一性和短生命周期**：
> Token通常是唯一的，并且有一个短的生命周期。即使攻击者获取了Token，也很快会失效，减少了被滥用的风险。
> 4. **双重提交Cookie**：
> 一种防止CSRF的策略是双重提交Cookie，即在请求中同时发送Token作为cookie和请求参数。服务器验证这两个Token是否匹配，从而防止CSRF攻击。
> 5. **使用CSRF Token**：
> 在某些情况下，应用程序会生成一个CSRF Token，并在每个请求中要求客户端提交这个Token。这个Token是随机生成的，并与用户的会话绑定，攻击者无法预测或伪造。

[参考1](https://blog.csdn.net/swadian2008/article/details/104267034)